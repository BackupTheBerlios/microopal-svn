/*
*	MicroOpal - compiler for a very simple opal slang written in opal
*	Copyright (C) 2005 Jan Kechel, Marc Schachtel
*
*	This program is free software; you can redistribute it and/or
*	modify it under the terms of the GNU General Public License
*	as published by the Free Software Foundation; either version 2
*	of the License, or (at your option) any later version.
*
*	This program is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*
*	You should have received a copy of the GNU General Public License
*	along with this program; if not, write to the Free Software
*	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*
*
*	the syntax-checker
*
*	to test this checker with oasys try:
*
*	#oasys
*	>f Checker.impl
*	Checker.impl>e checktest("fac")
*
*	Where fac ist the basename of a sourcefile ending with .mo (in this example: fac.mo)
*
*	Steps:
*	1. create base-environment with reserved words
*	2. parse 1st level of all DEFs in Absy, and add function-names to environment
*   3. foreach DEF
*      - a) add DEF variable-names to Environment
*      - b) check DEF
*/
IMPLEMENTATION Checker

IMPORT	Diag		COMPLETELY
	Pos		COMPLETELY
	Options COMPLETELY
	Absy COMPLETELY
	Scanner ONLY scantest
	Token COMPLETELY
	Seq COMPLETELY
    String COMPLETELY
	StringConv COMPLETELY
	Parser COMPLETELY
	Denotation COMPLETELY

DATA checkResult == 
	success
	failure(reasons: diag)

DATA type   == sort func unknown
DATA result == result(type: type, diag: diag)
DATA info   == info(args: seq[type], res: type)
DATA datatype == number boolean


-- the Environment will be a sequence of env's, carrying identifier, type (func or sort) and return-type
DATA env ==
	env(name:string, type:type, returns:datatype) 

-- adds a sort to the environment
FUN addSortToEnv : string ** datatype ** seq[env] -> seq[env]
DEF addSortToEnv(id, datatype, e) == 
	::(env(id, sort, datatype), e)

-- adds a function to the environment
FUN addFuncToEnv : string ** datatype ** seq[env] -> seq[env]
DEF addFuncToEnv(id, returndatatype, e) == 
	::(env(id, func, returndatatype), e)

-- returns true if the id is in this environment
FUN isIdInEnvironment : string ** seq[env] -> bool
DEF isIdInEnvironment(id, e) ==
	IF <>?(e) THEN
		false
	ELSE
		IF name(ft(e)) = id THEN
			true
		ELSE
			isIdInEnvironment(id , rt(e))
		FI
	FI
	
		

-- getBaseEnv creates the basic Environment for MicroOpal-Programs (e.g. adding reserved functions)
FUN getBaseEnv : seq[env]
DEF getBaseEnv == 
	::(env("add"!, func, number), 
	::(env("mul"!, func, number), 
	::(env("sub"!, func, number), 
	::(env("div"!, func, number), 
	::(env("eq"!, func, boolean), 
	::(env("lt"!, func, boolean), 
	::(env("and"!, func, boolean), 
	::(env("or"!, func, boolean), 
	::(env("not"!, func, boolean), 
	   <>)))))))))

DEF check(Opts, Absy) ==
    failure(error(global, "the context checker is not yet implemented!"))

-- just to test the checker from oasys
DEF checktest(s) ==
		LET 
			pr == parse(options(false, false, false, s), scantest(s))
		IN
			IF success?(pr) THEN
				check(options(false, false, false, s), absy(pr))
			ELSE
				failure(error(global, "parser error"))
			FI

DEF `(success) == "checkResult success"
DEF `(failure(a)) == "checkResult failure: '" ++ `(a) ++ "'"

-- Function-Names with types
FUN check_func_nat_nat_nat    : string ** seq[string] -> checkResult -- add, mul, sub, div
DEF check_func_nat_nat_nat(name, params) ==
	IF (name = ("add"!)) or (name = ("mul"!)) or (name = ("sub"!)) or (name = ("div"!)) THEN
		success
	ELSE
		failure(error(global, "not here"))
	FI
	
-- returns true if the name is reserved
FUN is_reserved_name : string -> bool

DEF is_reserved_name(name) ==
	IF 
		(name = ("add"!)) or (name = ("mul"!)) or (name = ("sub"!)) or (name = ("div"!)) or
		(name = ("eq"!)) or (name = ("lt"!)) or
		(name = ("and"!)) or (name = ("or"!)) or 
		(name = ("not"!)) or 
		(name = ("main"!))
	THEN
		true
	ELSE	
		false
	FI	

-- addEnvironmentForDef
-- stores all information into the Environment that is valid for this DEF-Block
-- params:  Def'Absy
-- returns: env
FUN addEnvironmentForDef : absy ** seq[env] -> seq[env]
DEF addEnvironmentForDef(d,e) == e

--FUN	check_func_nat_nat_bool   : string ** seq[string] -> checkResult -- eq, lt
--FUN	check_func_bool_bool_bool : string ** seq[string] -> checkResult -- and, or
--FUN	check_func_bool_bool      : string ** seq[string] -> checkResult -- not


--	add( param1:nat, param2:nat, return:nat)
--	mul( param1:nat, param2:nat, return:nat)
--	sub( param1:nat, param2:nat, return:nat)
--	div( param1:nat, param2:nat, return:nat)

--	eq(  param1:nat, param2:nat, return:bool)
--	lt(  param1:nat, param2:nat, return:bool)

--	and( param1:bool, param2:bool, return:bool)
--	or(  param1:bool, param2:bool, return:bool)
--	not( param1:bool, return:bool)

	
-- THE END
