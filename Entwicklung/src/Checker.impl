/*
*	MicroOpal - compiler for a very simple opal slang written in opal
*	Copyright (C) 2005 Jan Kechel, Marc Schachtel
*
*	This program is free software; you can redistribute it and/or
*	modify it under the terms of the GNU General Public License
*	as published by the Free Software Foundation; either version 2
*	of the License, or (at your option) any later version.
*
*	This program is distributed in the hope that it will be useful,
*	but WITHOUT ANY WARRANTY; without even the implied warranty of
*	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*	GNU General Public License for more details.
*
*	You should have received a copy of the GNU General Public License
*	along with this program; if not, write to the Free Software
*	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*
*
*	the syntax-checker
*
*	to test this checker with oasys try:
*
*	#oasys
*	>f Checker.impl
*	Checker.impl>e checktest("fac")
*
*	Where fac ist the basename of a sourcefile ending with .mo (in this example: fac.mo)
*
*	Steps:
*	1. create base-environment with reserved words
*	2. parse 1st level of all DEFs in Absy, and add function-names to environment
*   3. foreach DEF
*      - a) add DEF variable-names to Environment
*      - b) check DEF
*/
IMPLEMENTATION Checker

IMPORT	Diag		COMPLETELY
	Pos		COMPLETELY
	Options COMPLETELY
	Absy COMPLETELY
	Scanner ONLY scantest
	Token COMPLETELY
	Seq COMPLETELY
    String COMPLETELY
	StringConv COMPLETELY
	Parser COMPLETELY
	Denotation COMPLETELY

DATA checkResult == 
	success
	failure(reasons: diag)

DATA type   == sort func unknown
DATA datatype == number boolean unknown

DEF `(sort) == "sort"
DEF `(func) == "func"
DEF `(unknown:type) == "unknown"

DEF `(number) == "number"
DEF `(boolean) == "boolean"
DEF `(unknown:datatype) == "unknown"

DEF `(env(n, func, r, p)) == 
	"\nfunc: " ++ `(n) ++ ", returns: " ++ `(r) ++ " expected args: (" ++ `(p) ++ ")"

DEF `(env(n, sort, r, p)) == 
	"\nsort: " ++ `(n) ++ ", type:" ++ `(r) 

DEF printEnv(s) ==
	IF <>?(s) THEN
		""
	ELSE
		"\n----------------------------\n" ++
		"Currently known Identifiers:\n" ++ 
		pEnv(s) ++ 
		"\n----------------------------\n"
	FI

DEF pEnv(s) ==
	IF <>?(s) THEN
		""
	ELSE
			`(ft(s)) ++ pEnv(rt(s))
	FI


DEF `(a) == 
	IF <>?(a) THEN
		""
	ELSE
		IF <>?(rt(a)) THEN
			`(ft(a)) ++ `(rt(a))
		ELSE
			`(ft(a)) ++ ", " ++ `(rt(a))
		FI
	FI

-- the Environment will be a sequence of env's, carrying identifier, type (func or sort) and return-type
DATA env ==
	env(name:string, type:type, returns:datatype, pars:seq[datatype]) 


-- the 'main' function of this module (exported in .sign)
DEF check(o, a) ==
	LET
		(cr, dtt, _) == chk(a, getBaseEnv)
	IN
		cr

FUN eq : datatype ** datatype -> bool
DEF eq(number, number) == true
DEF eq(boolean, number) == false
DEF eq(number, boolean) == false
DEF eq(boolean, boolean) == true
DEF eq(_,_) == false

-- returned was zur environment hinzugefuegt werden soll
-- wird nur bei FuncDecl und drunterliegenden verwendet
FUN chk : absy ** seq[env] -> checkResult ** datatype ** seq[env]

-- Prog Knoten checken
DEF chk(Prog(ftt,rtt), e) ==
	LET
		(cR1, dtt1, ad1) == chk(ftt, e)
	IN
		IF success?(cR1) THEN
			LET
				(cR2, dtt2, ad2) == chk(rtt, ::(ft(ad1), e)) -- add new function to env
			IN
				IF success?(cR2) THEN
					(success, dtt1, <>)
				ELSE
					(cR2, dtt2, <>)
				FI
		ELSE
			(cR1, dtt1, <>)
		FI

-- Def Knoten checken
DEF chk(Def(fd, fi, toks), e) ==
	LET
		(cR1, dtt1, ad1) == chk(fd, e)
	IN
		IF success?(cR1) THEN
				--(failure(error(global, "Def exports into implementation" ++ printEnv(ad1) ++ "\nto" ++ printEnv(e))), dtt1, ad1)
			LET
				(cR2, dtt2, ad2) == chk(fi, ad1 ++ e) -- ok, deklaration mit in implementation uebernehmen
			IN
				IF success?(cR2) THEN
					IF eq(dtt1, dtt2) THEN
						(success, dtt1, ::(ft(ad1), <>))
						--(failure(error(global, "Def exports" ++ printEnv(::(ft(ad1), <>)) ++ "\nto" ++ printEnv(e))), dtt1, ad1)
					ELSE
						(failure(error(pos(ft(toks)), "Def declaration and implementation return different datatypes. DEF declared " ++ `(dtt1) ++ " but implementation returns a " ++ `(dtt2) ++ printToks(toks))), unknown, <>)
					FI
				ELSE
					(cR2, dtt2, <>)
				FI
		ELSE
				(cR1, dtt1, <>)
		FI

-- FuncDecl Knoten checken, Environment durch Parameter erweitern
DEF chk(FuncDecl(n, t, p, toks), e) ==
	LET 
		(b, en) == isIdInEnvironment(n, e)
	IN
		IF b THEN
			(failure(error(pos(ft(toks)), "name already exists" ++ printToks(toks))), boolean, <>)
		ELSE
			LET
				(cR1, dtt1, ad1) == chk(t, e)
			IN
				IF success?(cR1) THEN
					IF n = ("MAIN"!) THEN -- check for main
						LET
							mainfunc == env(n, func, dtt1, <>)
						IN
						(success, dtt1, ::(mainfunc, <>)) -- ok, main hat keine parameter!
						--(failure(error(global, "Main found: " ++ `(mainfunc))), unknown, <>)
					ELSE
						IF SingleArg?(p) THEN -- falls nur ein parameter, dann hat der absy keinen ParamsDecl-Knoten
							LET
								(cR2, dtt2, ad2) == chk(p, e)
								newfunc == env(n, func, dtt1, ::(dtt2, <>))  -- neue funktion bauen
							IN
								IF success?(cR2) THEN
									(success, dtt1, ::(newfunc, ad2))
								ELSE
									(cR2, dtt2, <>)
								FI
						ELSE

							LET
								newfunc == env(n, func, dtt1, <>)  -- neue funktion bauen
								(cR2, dtt2, ad2) == chk(p, ::(newfunc, e))
							IN
								IF success?(cR2) THEN
									(success, dtt1, ad2) -- ok
								--	(failure(error(global, "FUncDecl exports: " ++ printEnv(ad2))), boolean, <>)
								ELSE
									(cR2, dtt2, <>)
								FI
						FI
					FI
				ELSE
					(cR1, dtt1, <>)
				FI
		FI

DEF chk(Type(n, toks), e) ==
	IF n = ("nat"!) THEN
		(success, number, <>)
	ELSE
		IF n = ("bool"!) THEN
			(success, boolean, <>)
		ELSE
			(failure(error(pos(ft(toks)), "'nat' or 'bool' expected" ++ printToks(toks))), boolean, <>)
		FI
	FI

DEF chk(SingleArg(n, t, toks), e) ==
	LET 
		(cR1, dtt1, _) == chk(t, e)
	IN
		IF success?(cR1) THEN
			-- eigenes arg in env und return datatype of arg
			LET
				newsort == env(n, sort, dtt1, <>)
			IN
				(cR1, dtt1, ::(newsort, <>))  -- neue sort zurueckgeben
		ELSE
			(cR1, dtt1, <>)
		FI

-- erwartet aktuelle funktion als erstes element in env, oder letztes argument
DEF chk(ParamsDecl(p1, p2, toks), e) ==
	LET
		(cr2, dtt2, ad2) == chk(p2,  e)
	IN
		IF success?(cr2) THEN
			LET
				(cr1, dtt1, ad1) == chk(p1, ad2 ++ e) 
			IN
				IF success?(cr1) THEN
					IF sort?(type(ft(ad2))) THEN
						LET
							-- with this arg as new 1st param
							newfunc == env(name(ft(e)), type(ft(e)), returns(ft(e)), ::(dtt1, ::(dtt2, <>))) 
						IN
							(success, unknown, ::(newfunc, ad2 ++ ad1))
							--(failure(error(global, "pd1: " ++ printEnv(::(newfunc, ad1 )))), boolean, <>)
					ELSE
						LET
							-- with this arg as new 1st param
							newfunc == env(name(ft(e)), type(ft(e)), returns(ft(e)), ::(dtt1, pars(ft(ad2))))
						IN
							(success, unknown, ::(newfunc, rt(ad2) ++ ad1))
							--(failure(error(global, "pd2: " ++ printEnv(::(newfunc, rt(ad2) ++ ad1)))), boolean, <>)
					FI
				ELSE
					(cr1, dtt1, <>)
				FI
		ELSE
			(cr2, dtt2, <>)
		FI

DEF chk(ExprTerm(t, toks), e) ==
	IF t = ("true"!) THEN
		(success, boolean, <>)
	ELSE
		IF t = ("false"!) THEN
			(success, boolean, <>)
		ELSE
			(success, number, <>)
		FI
	FI
		
--				(failure(error(global, "error in exprterm")), boolean)

DEF chk(ExprFunc(n, p, toks), e) ==
	LET
		(b, en) == isIdInEnvironment(n, e)
	IN
		IF b THEN
			IF func?(type(en)) THEN -- ja, ist eine funktion
				LET 
					(cr1, dtt1, ad1) == chk(p, ::(en, e)) -- checke parameter
				IN
					IF success?(cr1) THEN
						--(failure(error(global, "func call:" ++ `(n) ++ " with "  ++ printEnv(e))), unknown, <>)
						(cr1, returns(en), <>) -- add current function as first element in environment, return-type as in environment
					ELSE
						(cr1, unknown, <>)
					FI
			ELSE
				(failure(error(pos(ft(toks)), "Identifier is not a function:" ++ printToks(toks))), unknown, <>)
			FI
		ELSE
				(failure(error(pos(ft(toks)), "Identifier not found: " ++ printToks(toks) ++ printEnv(e))), unknown, <>)
		FI

-- expects env of current function as 1st element in seq[env]
DEF chk(Params(f, r, toks), e) ==
		IF <>?(pars(ft(e))) THEN -- wenn parameter uebergeben, aber funktion keinen mehr benoetigt
			(failure(error(pos(ft(toks)), "Too many arguments, function '" ++ `(name(ft(e))) ++ "' needs less parameters" ++ printToks(toks) )), unknown, <>)
		ELSE
			IF Empty?(r) THEN -- also ok
				IF <>?(rt(pars(ft(e)))) THEN -- wenn keine argumente folgen, dann muss rechts empty stehen
					LET
						(cr1, dtt1, ad1) == chk(f, rt(e)) -- check current param 
					IN
						IF success?(cr1) THEN
							IF eq(dtt1, ft(pars(ft(e)))) THEN -- wenn verlangter parameter = uebergebener parameter
									-- ok, also erster parameter gecheckt, 
									-- diesen nun entfernen und nochmal mit einem parameter weniger fuer den rest
								LET
									en == env(name(ft(e)), type(ft(e)), returns(ft(e)), rt(pars(ft(e))))
								IN
									(success, unknown, ::(en, rt(e)))
								--(failure(error(global, "last parameter:" ++ `(ft(pars(ft(e)))) ++ " but got " ++ `(dtt1) ++ printEnv(e))), unknown, <>)
							--		chk(r, ::(en, rt(e))) -- also success, ersetzen und den rest checken
							ELSE
								(failure(error(pos(ft(toks)), "Parameter mismatch: expected " ++ `(ft(pars(ft(e)))) ++ " but got " ++ `(dtt1)  ++ printToks(toks))), unknown, <>)
							FI
						ELSE
							(cr1, dtt1, <>)
						FI
				ELSE
					(failure(error(pos(ft(toks)), "- Too few arguments, function '" ++ `(name(ft(e))) ++ "' needs more paramters " ++ printToks(toks))), unknown, <>)
				FI
			ELSE -- ok, also nicht letzter parameter und auch nicht empty in r
				IF <>?(rt(pars(ft(e)))) THEN -- wenn keine argumente folgen, dann haette rechts empty stehen muessen
					(failure(error(pos(ft(toks)), "- Too many arguments, function '" ++ `(name(ft(e))) ++ "' needs less paramters "  ++ printToks(toks))), unknown, <>)
				ELSE
					LET
						(cr1, dtt1, ad1) == chk(f, rt(e)) -- check current param 
					IN
						IF success?(cr1) THEN
							IF eq(dtt1, ft(pars(ft(e)))) THEN -- wenn verlangter parameter = uebergebener parameter
									-- ok, also erster parameter gecheckt, 
									-- diesen nun entfernen und nochmal mit einem parameter weniger fuer den rest
								LET
									en == env(name(ft(e)), type(ft(e)), returns(ft(e)), rt(pars(ft(e))))
								IN
									--(failure(error(global, "not last parameter:" ++ `(ft(pars(ft(e)))) ++ " but got " ++ `(dtt1) ++ printEnv(e))), unknown, <>)
									chk(r, ::(en, rt(e))) -- also success, ersetzen und den rest checken
							ELSE
								(failure(error(pos(ft(toks)), "Parameter mismatch: expected " ++ `(ft(pars(ft(e)))) ++ " but got " ++ `(dtt1) ++ printToks(toks))), unknown, <>)
							FI
						ELSE
							(cr1, dtt1, <>)
						FI
					FI
			FI
		FI

DEF chk(ExprCond(if, then, else, toks), e) ==
	LET
		(cr1, dtt1, ad1) == chk(if, e)
		(cr2, dtt2, ad2) == chk(then, e)
		(cr3, dtt3, ad3) == chk(else, e)
	IN
		IF success?(cr1) THEN
			IF success?(cr2) THEN
				IF success?(cr3) THEN

					IF eq(dtt1, boolean) THEN
						IF eq(dtt2, dtt3) THEN
							(success, dtt2, <>)
						ELSE
							(failure(error(pos(ft(rt(toks))), "THEN and ELSE part return different datatypes THEN: " ++ `(dtt2) ++ " ELSE: " ++ `(dtt3) )), unknown, <>)
						FI
					ELSE
						
						(failure(error(pos(ft(toks)), "Condition in IF is not a boolean")), unknown, <>)
					FI
				ELSE
						(cr3, dtt3, <>)
				FI
			ELSE
				(cr2, dtt2, <>)
			FI
		ELSE
			(cr1, dtt1, <>)
		FI

DEF chk(ExprId(n, toks), e) ==
	LET
		(b, en) == isIdInEnvironment(n, e) 
	IN
		IF b THEN
			(success, returns(en), <>)
		ELSE
			(failure(error(pos(ft(toks)), "Unknown variable: " ++ printToks(toks) ++ printEnv(e))), unknown, <>)
		FI

DEF chk(Error(s, toks), e) ==
	(failure(error(pos(ft(toks)), `(s))), boolean, <>)

-- also wenn keine weiteren parameter angegeben
DEF chk(Empty(s), e) ==
		(success, unknown, <>)

-- just to test the checker from oasys
DEF checktest(s) ==
		LET 
			pr == parse(options(false, false, false, s), scantest(s))
		IN
			IF success?(pr) THEN
				check(options(false, false, false, s), absy(pr))
			ELSE
				failure(error(global, "parser error"))
			FI


DEF chk(_, _) == 
			(failure(error(global, "broken absy, correct parser!")), boolean, <>)

DEF `(success) == "checkResult success"
DEF `(failure(a)) == "checkResult failure: '" ++ `(a) ++ "'"


-- returns true if the id is in this environment
DEF isIdInEnvironment(id, e) ==
	IF <>?(e) THEN
		(false, env("error"!, func, boolean, <>))
	ELSE
		IF name(ft(e)) = id THEN
			(true, ft(e)) 
		ELSE
			isIdInEnvironment(id , rt(e))
		FI
	FI
	
		
-- getBaseEnv creates the basic Environment for MicroOpal-Programs (e.g. adding reserved functions)
DEF getBaseEnv == 
	::(env("add"!, func, number, ::(number, ::(number, <>))), 
	::(env("mul"!, func, number, ::(number, ::(number, <>))), 
	::(env("sub"!, func, number, ::(number, ::(number, <>))), 
	::(env("div"!, func, number, ::(number, ::(number, <>))), 
	::(env("eq"!, func, boolean, ::(number, ::(number, <>))), 
	::(env("lt"!, func, boolean, ::(number, ::(number, <>))), 
	::(env("and"!, func, boolean, ::(boolean, ::(boolean, <>))), 
	::(env("or"!, func, boolean, ::(boolean, ::(boolean, <>))), 
	::(env("not"!, func, boolean, ::(boolean, <>)), 
	   <>)))))))))

-- THE END
